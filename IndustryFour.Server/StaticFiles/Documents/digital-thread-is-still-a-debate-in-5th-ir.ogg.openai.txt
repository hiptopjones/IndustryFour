Answering your questions about the 5th Industrial Revolution, digital thread, unified namespace and the impact of AI on the future of manufacturing, take zero. Alright, so later on in this video, in the second question that I answer, I'm actually going to show you a bunch of examples of digital thread architectures. And then I'm actually going to show you an actual use case of what we do here at 4.0 Solutions using digital thread with a unified namespace. The idea is to contrast the two, because we get a lot of questions about digital thread. What is it? Why are you so tough on it, Walker? Blah, blah, blah, blah. I'm going to answer those questions. I'm going to answer that question second. I've got two questions I'm going to answer in this video. So, what we're going to do is we're going to start. I'm going to jump right in. On a LinkedIn post about a week ago, I published a post about the 5th Industrial Revolution. And I just said, what does the start of the 5th Industrial Revolution launched by natural language processing mean for manufacturers? Well, this has been part of the plan all along. AI has always been a key component of achieving industry 4.0 goals. It is just here and viable sooner than we thought. What we're talking about here is tools like ChatGPT, Copilot for GitHub, etc. What should orgs be doing? It's quite simple. If you've started your digital transformation journey, that is, you have a digital strategy, architecture, minimum technical requirements for infrastructure, then you keep going and you incorporate machine learning and AI, natural language processing like ChatGPT for AI and human interface. You also might hear this called LLM, which is language learning models. If you haven't started your journey, start now with digital strategy. The why do we want to be a digital company? Breathe, exciting times are before us. And then what I did was I pointed out, this is a slide we've been using, honestly, for years. What is the whole point of industry 4.0? The 4th Industrial Revolution was all about the automation of business processes. Actually, this is kind of important. Why is it that I'm saying the 5th Industrial Revolution has started? Trust me, the rising edge of the 5th Industrial Revolution will be traced back to November of 2022 with the release of ChatGPT. Officially, no one has defined it as the 5th Industrial Revolution yet. Right now, because of the current state of the global economy and the influence of the World Economic Forum and all these big, huge organizations who are trying to redefine our economy, what people are trying to say is that the 5th Industrial Revolution is going to be all about people, sustainability. It's going to be about the circular economy. It is not. The reason why is we're just not there yet. The 5th Industrial Revolution is really going to be about the convergence of the physical world and the virtual world, insofar as human beings will be leveraging artificial intelligence to become superhuman beings. And at the exact same time, technology will make it possible to put the best people on the toughest problems, no matter where that problem is in the world. That is the 5th Industrial Revolution, and it starts with ChatGPT. But this slide is a slide we've been using for a couple of years now. What was the point of the 4th Industrial Revolution? The 3rd Industrial Revolution was about the automation of business processes, or industrial processes, that is, equipment on the plant floor. It was about automating equipment to make equipment more efficient, the manufacturing process more efficient. The 4th Industrial Revolution, the rising edge of the 4th Industrial Revolution was when TCPIP won the Protocol War. So we're actually going to be doing a series on the history of automation. What I'm going to do, I'm literally in the studio here. We're trying to collaborate with a guy who's based here in Dallas as well, a big YouTuber. He's got millions of subscribers. We're going to try and collaborate with him, where I'm going to be the automation guy, he's going to be the computer guy. We're going to talk about the progression of automation over the last 40 years. And we're going to set up old PLCs and computers. We're going to show, we're going to try to illustrate why the 4th Industrial Revolution happened. What was the thing that changed that made the 4th Industrial Revolution possible? And that was TCPIP winning the Protocol Wars in the late 90s. Suddenly, through that reality, it became possible to merge all the data that was created through the 3rd Industrial Revolution on the plant floor, with all the data that was created through the Internet Revolution on the business side. And that's called OTIT convergence. And that made it possible for you to create smart businesses where data is your primary commodity. The 5th Industrial Revolution is about emerging the results of that convergence, that is artificial intelligence and machine learning, with human beings, to put the best human beings on the toughest problems. That's the 5th Industrial Revolution. That's where we are right now. This slide right here, though, shows what companies should be trying to do during the 4th Industrial Revolution. So they want to make a fully integrated business made up of digital factories. Everything and everyone is plugged into a network. The layers of the business are integrated and operate based on data and information from all the other layers in real time. Stakeholders know the state of the business in real time. Stakeholders know the future state of the business in real time. We leverage technology, specifically machine learning and artificial intelligence, to collect and analyze data information. What we like to say is we use software to find patterns and data that humans can't see with the naked eye. Machine learning will predict future outcomes based on past patterns and current state. And artificial intelligence will recommend operational adjustments to improve future outcomes. You can literally take the input, you take the output of machine learning, you can drop it into a natural language processor like ChatGPT, and ChatGPT will be able to make recommendations on what our intervention should be. Now, will it be ChatGPT that does that? No. It'll be a natural language processor that's trained on your specific data. And then stakeholders will decide whether or not to execute those recommended operational adjustments. The human being interacting with the AI will decide what to execute or whether or not to fine-tune the recommendation. But there was a question, there was a comment in this, you know, Alessandro Ovando Bodino, he's a founder and CEO, I'm not sure of what, but he said, Exciting times for sure. Although I wonder, with so many businesses just getting their bearings with 4.0, let alone taking full advantage of 3.0, is there a risk of overselling and under-delivering, especially for small manufacturers with so few quality data? Still, at the very least, natural language processing will definitely bring, will bring a revolution in PLC HMI design and usage on the production floor. Is there a risk of overselling and under-delivering? Yes, absolutely. There always has been. I mean, a huge reason why we shoot these videos is because, you know, what is our key message? You know, at the end of the day, what is our message? Our mission is to help save and create middle-class jobs in the United States. Like, if the technology is used for good, then you can revitalize the middle class through the revitalization of manufacturing in the United States. Now, and by the way, we're going to shoot future videos that show that we're actually making an impact in this arena, that, you know, the U.S. is really leading the global renaissance in manufacturing, and you can thank the fourth industrial revolution for that. The Americans took an approach that the European Union did not take, and it's much more effective in the United States than it is in the EU, okay? One of the challenges, though, has always been people who are going to try to exploit the ignorance of the market. And believe me, there are a lot of people out there who either know what they're talking about and are intentionally choosing to mislead their customers, and this has been going on for decades, or there are people who have no idea what they're talking about, and they're pretending like they do, okay? So, yes, there is a huge risk that people will oversell and underdeliver, okay? I mean, think about it. You know, since 2018, we've been pushing this message strongly. Five years now, I've spent millions of dollars trying to communicate to organizations how to successfully digitally transform through digital media, and there's still a lot of misinformation out there, okay? And I'm going to hope in the next question to answer and respond to some of that misinformation. But anyway, great question. Yes, there is a challenge. There is a risk of overselling and underdelivering. How do you overcome that? You know, the importance of working with agnostic partners cannot be overstated, okay? And if you want to know more about what I mean by agnostic partners, agnostic architects, I bring it up in lots of our other videos. All right. So a couple days after that, I posted, I had a great call with a client yesterday. He asked, what's wrong with the digital thread? And my answer in a nutshell is that data objects are threaded in one direction up the stack, stored, and then extracted for analysis and then visualized. Great for dashboards, terrible for digital infrastructure. The main flaw, digital threads breaks two cardinal rules. Number one, all data matters, makes no assumption, make no assumptions about how it's going to be consumed. And number two, all smart nodes are producers and consumers of data and information. Digital thread has no mechanism for producers to consume information created as the thread moves up the stack. Reason 1001 why the unified namespace exists. Now, I'm going to show you an actual architecture that we use internally, okay, where we have a thread. We do have a digital thread that we've created. But how we use that digital thread to integrate with the unified namespace so that we're not breaking those two rules, okay? There was a lot of comments in this LinkedIn post that I made. And a lot of them were, hey, if you go Google this, it says that digital thread is bidirectional. It says that digital thread is especially bidirectional when it comes to product lifecycle management. And Ali Ahmed, who I'm going to read his comments here in a second, he went to ChatGPT. And ChatGPT said, well, while there are cases where it is unidirectional, it can be bidirectional. Well, first off, I didn't say that it can't be bidirectional. That's always a function of time and money. You can make anything bidirectional. But the amount of money you spend sending the data up the stack is the same amount of money you're going to spend sending the data down the stack. So what my argument is is because of the flaws in the architecture of digital thread, A, that it's deterministic, that you create an object, that object is what the thread is actually made of. You store it in the shape of that object. You call it in the shape of that object. You visualize it in the shape of that object. There is a problem with that. And that is there's lots and lots of context that that thread passes right by as it's moving up to the cloud. And I dropped in a little what is a typical digital thread architecture look like over here on the left-hand side. So you've got edge devices out here on the floor. You'll put an edge IoT gateway out there. And this is what you'll see most organizations trying to sell you, some edge IoT gateway. And what's happening inside that gateway? Well, they have a native connector that talks to that edge device. They're creating a model, which is the object, the thread. They store it locally. And then they have a connector that gets it to its cloud platform. And then they basically take the object and they move it to the cloud platform. And then they assume that other things will retrieve it in the cloud. What happens in the cloud? It goes from connector primarily into a data lake. And then there's some type of API that calls that object for analysis. And then you visualize it in some type of dashboarding platform. This is how Azure does it. It's how AWS does it. It's how Litmus Automation does it. It's how Sorbet AI does it. It's how lots and lots and lots of companies do it. They do it what's here on the left-hand side. Now, I'm going to show you – actually, let me go ahead and – well, actually, let me show you just some examples of architectural drawings. If you were to go look for drawings online on what the digital thread is, you will not get one consistent drawing. So this one, I can't remember who made this drawing here, but what they've got is a digital thread in the middle. The top side is the physical layer. The bottom side is the digital layer. And this is meant to make you think that, essentially, there's a data bus here in the center, okay, that there's a data bus, and that data bus, whatever I can consume here in this digital definition, I can consume here in additive manufacturing. That is not the case. There are certain examples in digital thread where, let's say I were to just settle, I would make my entire infrastructure, nothing but Azure IoT. So that is literally everything is Azure IoT or Azure Partners. Then I could possibly create a data bus in the center of the business that would account for most context for my data object. But that just doesn't happen. The reason why is it's too expensive. You've either got to rip everything out and replace it with your thing, or you've got to do a combination of rip and replace and new, and you are limited to a small sliver of the possible digital solutions out there that could help your business. But if you look at these architectures, they're all completely different. Even Kepware or PTC does digital thread as a circle. I'm going to show you how it actually plays out in practice, what a digital thread actually looks like. It looks like this. If you go and you look at a digital thread infrastructure, believe me, I review these all the time, it looks like this. It doesn't mean that there aren't scenarios where maybe data is bidirectional in one place. Like let's say maybe data is bidirectional in this layer, but is it ever bidirectional here to here? Never. I've never seen an example of it using thread ever. The most common is an asset frame, and then you essentially pass it up the stack through connectors, and then you dashboard it at the top. You do intelligent asset optimization, et cetera, et cetera. Let's go ahead and read Ali's question. I'll answer it, and then I'm going to show you an actual architecture. Ali said, Walker, what is your comment on this Chad GPT answer part one? The statement you mentioned. What he did was he took what I wrote here. He dropped it into Chad GPT, and this was Chad GPT's response. It said, the statement you mentioned is not entirely accurate. While it's true that in some implementations of a digital thread, the primary flow of data is from the edge devices bottom to the cloud or higher level systems top, it is entirely possible to enable bidirectional communication and send data from the top to the bottom as well. This is true, but it's a function of time and money. The actual implementation looks like this. This is what you end up with. The reason why is, let's say I wanted to – I've got my manufacturing execution system here that's calculating, managing work orders, building formulations from our recipes, calculating OEE and TEEP. There needs to be an integration from here into my thread and then a data mechanism to take the context that was added to the object and get it back down to, say, my PLC. That is a linear manual integration. It is not native to the architecture. That is, as soon as I put OEE in here, everything that's connected to the infrastructure has access to OEE. No, I have to have a point-to-point integration to get the OEE calculation for this asset into that PLC. So while it is possible, it is not practical, and therefore it is not done, which is also the reason why you see these – for all these architectures for digital thread looking completely different. Looking completely different. The architecture for unified namespace always looks the same. Chad Chippity continues, in many industrial automation and IoT systems, operational communication is crucial for allowing remote control, configuration, or updates from higher-level systems or cloud services. Correct. But the remote control is generally supervisory control and data acquisition software, which is legacy, to PLC, which is your process control on the plant floor, and that's not part of your thread. You may use elements from, say, I'm using control logics, PLCs, and I got add-on instructions or user-defined data types for my various assets. I may create a thread out of those objects, but I'm not changing the add-on instruction or the user-defined data type to now have a parameter for overall equipment effectiveness that I can write to. And if I do, I've got to go to my PLC program and I have to add that. For example, you might need to change the set points of a controller, send firmware updates to a device. By the way, that's hardware management. That's not data management. Or remotely trigger an action in response to an event or alarm. This is something that's very commonly handled with digital thread, but it's done, again, with a point-to-point integration. To enable bidirectional communication in a digital thread, you need to consider the following aspects. You need to use a communication protocol that supports bidirectional data transfer, such as MQTT, which is how we do this, OPC UA, or RESTful APIs. These protocols allow devices and systems to both send and receive data, enabling communication in both directions. Data model, you have to design your data model to accommodate both up-to-down and down-to-up data flows. Exactly. Okay? Here's my point. We talk about self-aware SCADA all the time. And what is the concept of self-aware supervisor-controlled data acquisition using a unified namespace? And the concept is this. If I make a change on the edge, which is where my business happens, that is, I make a change to a process, which happens all the time, you have armies of technicians and engineers and electricians who are making changes to your process control all the time, and that's where your business happens. You want that update to push to your visualization. You don't want to have to go to your visualization and implement that update. That's self-aware. Self-aware is built on top of a self-aware infrastructure, not a linear point-to-point integration. Okay? Security, edge device capabilities. Okay. The point is, Chad GPT responds with the things that you would need. Okay? But Chad GPT doesn't tell you that the things that you need don't come out of the box with the organizations that are creating these drawings. Okay? It's time and money. All right? So let's take a look at an actual integration. Okay? So this is an actual integration of a digital thread. This is a literal, and I'll show you the example of the namespace here in a second. Okay? So what we have inside of our business is we had a need to extract business information from one of our business systems. Okay? That is payment information. We needed to extract payment information from one of our business systems. Okay? We needed to know, just so that we could manage, you know, making sure that people who have certain subscriptions have access to the things that they've purchased. We know the number, you know, we need to know who is in every one of the classes that we offer. So we had a need to go to one of the business systems that we use, which does not support our business infrastructure out of the box. Okay? And extract that information. And we did that by creating a digital thread. So what we have are three threads that are created. Okay? Every 24 hours we create a threaded object, a digital object for our business. We create three of them. Okay? One every 24 hours, one every 15 minutes. Okay? The way that this works is if I were doing just the digital thread piece, so let's say I wanted to solve my problem using thread, it would be just this piece here. Okay? So this would be the edge. I have an edge device. So I have my business system. I have an edge device that's going to pull my business system and create three objects. Those three objects are then going to store the data into a data store. Okay? Okay? So I'm going to have an API that stores the data into a data store. Then I'm going to have an API that extracts those objects, these three objects, from the data store and visualize them, in this case in Grafana. Okay? We didn't integrate it that way. Okay? What we did was we used elements of digital thread plus a unified namespace to create a self-aware infrastructure, a self-aware ecosystem. All right? So here's how it actually works. We have three threads that run. We have three edge devices that run. They create three digital objects. Those digital objects are stored inside of our unified namespace. They are published to an EMQX broker. This is Python running. This is Linux, this square here. There's Python. It stores the three digital objects inside of these two parts of our namespace. The 4.0 solutions, IOT.university, our KPIs, and our reports namespace. The reports are what all of our account managers use, what the educators use to know who is in what classes. Okay? These three threads are stored here. Then what we have is we have another connector that is monitoring the namespace. Okay? This is another piece that's written by us. It is monitoring the namespace, and then it extracts the data from the namespace and stores it into MySQL as historical transactions. Okay? Then we have a connector between MySQL and Grafana to display our objects. We also have a connector between our MQTT broker and Grafana to display any other object that doesn't come from this digital thread. For example, our Arduino PLC, which supports the technology out of the box. So this Arduino is not a digital thread. Okay? It is a digital object that is stateful, edge-driven, report by exception, and lightweight. Any changes to this Opta show up in here automatically. Okay? So the Opta publishes to the broker in the 40-sol Dallas Opta Wi-Fi simulation Wi-Fi and status namespace. And so what I've got now is I have bidirectional communications all the way up to where the thread is created, the digital thread is created. So everything else communicates bidirectionally. The Arduino, MQTT, MySQL, MySQL server, and Grafana, they all communicate bidirectionally with our unified namespace. Therefore it means it has access to anything that gets added to the namespace. Guess what doesn't communicate bidirectionally? Our three digital thread objects. We do not. We could, we could publish back to our digital thread object here, and then we could take information from our namespace and send it to our business system. We don't. You want to know why? Because the cost of doing this part is prohibitive to the value.  This, this is digital thread. This is a digital thread example using business systems, not automation. This is digital thread with UNS and this is UNS.  Okay. This is an actual implementation. I mean, when I talk about digital thread, it's not because I'm just speculating. I mean, by the way, this is a simple example. This is a very simple example. Okay. All right. Hopefully that clarifies my position on digital thread. It's not that digital thread is useless. What I'm saying is, is digital thread is not effective for the infrastructure of your business. There are too many point to point integrations. There are too many points, by the way, every, every time I add something in this namespace, it ends up in my SQL. Now we're using my SQL. We'd normally use Kafka here, by the way. So generally what we would do is, you know, in a large enterprise systems, this is a Kafka stream. Okay. This is not my SQL. This is Kafka into a data lake. Right. But this is an example, since the scale is such, we can use my SQL and Grafana as opposed to using enterprise. By the way, there's no licensing cost here. This is another thing. This is a fully digital implementation that required no licenses. Okay. But when I talk about digital thread, what I'm saying is not that digital thread doesn't have a place, just like OPC UA. What I'm saying is it's not the foundation of your digital infrastructure. It's used in certain use cases. And in this case, where we're using a rest API that has a Python library, then we're going to go ahead and create digital threads. Think a very similar to like Lambda functions. All right. Hopefully that answers the question. Hopefully this is valuable. Remember to like scribe, subscribe, comment down below, commenting, and liking immediately are two of the most important things you can do. And I will see you in the next one.